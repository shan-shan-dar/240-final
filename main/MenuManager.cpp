#include "MenuManager.h"
#include "UIUtils.h"
#include <fstream>
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <ctime>
#include <sstream>
#include <map>
#include <cmath>
#include <cstdlib>

using namespace std;

// Helper function to trim whitespace from string
static string trim(const string& str) {
    size_t first = str.find_first_not_of(" \t\n\r");
    if (first == string::npos) return "";
    size_t last = str.find_last_not_of(" \t\n\r");
    return str.substr(first, last - first + 1);
}

// Constructor - menus are loaded on-demand from JSON files
// generated by menu.py (see menu.py for details). The filepath parameter
// is kept only for backward compatibility and is unused.
MenuManager::MenuManager(const string& filepath) {
    (void)filepath;
}

// Load menu from specific file path (for date-specific menus)
vector<FoodItem> MenuManager::loadMenuFromFile(const string& filename) {
    vector<FoodItem> menu;
    ifstream file(filename);

    if (!file.is_open()) {
        return menu;  // Return empty menu if file doesn't exist
    }

    string line;
    string currentStation = "";

    // Skip opening brace
    getline(file, line);

    while (getline(file, line)) {
        // Check for station name (e.g., "Provisions 804": [)
        // But exclude "icons": [ which is not a station
        if (line.find("\":") != string::npos && line.find("[") != string::npos) {
            size_t start = line.find("\"") + 1;
            size_t end = line.find("\"", start);
            string possibleStation = line.substr(start, end - start);

            // Only update station if it's not "icons", "serving_size", etc.
            if (possibleStation != "icons" && possibleStation != "serving_size") {
                currentStation = possibleStation;
            }
            continue;
        }

        // Look for "name" field to identify a food item
        if (line.find("\"name\"") != string::npos) {
            FoodItem item;
            item.station = currentStation;

            try {
                // Parse name
                size_t start = line.find(":") + 1;
                size_t end = line.find_last_of("\"");
                start = line.find("\"", start) + 1;
                item.name = line.substr(start, end - start);

                // Skip ingredients line
                getline(file, line);

                // Skip "nutrition": { line
                getline(file, line);

                // Parse calories
                getline(file, line);
                start = line.find(":") + 1;
                string calStr = line.substr(start);
                size_t commaPos = calStr.find(",");
                if (commaPos != string::npos) {
                    calStr = calStr.substr(0, commaPos);
                }
                calStr = trim(calStr);
                item.calories = static_cast<int>(stod(calStr));

                // Parse g_fat
                getline(file, line);
                start = line.find(":") + 1;
                string fatStr = line.substr(start);
                commaPos = fatStr.find(",");
                if (commaPos != string::npos) {
                    fatStr = fatStr.substr(0, commaPos);
                }
                fatStr = trim(fatStr);
                item.fats = stod(fatStr);

                // Parse g_carbs
                getline(file, line);
                start = line.find(":") + 1;
                string carbStr = line.substr(start);
                commaPos = carbStr.find(",");
                if (commaPos != string::npos) {
                    carbStr = carbStr.substr(0, commaPos);
                }
                carbStr = trim(carbStr);
                item.carbs = stod(carbStr);

                // Parse g_protein
                getline(file, line);
                start = line.find(":") + 1;
                string proteinStr = line.substr(start);
                commaPos = proteinStr.find(",");
                if (commaPos != string::npos) {
                    proteinStr = proteinStr.substr(0, commaPos);
                }
                proteinStr = trim(proteinStr);
                item.protein = stod(proteinStr);

                // Skip closing brace of nutrition
                getline(file, line);

                // Parse serving_size
                getline(file, line);
                if (line.find("serving_size") != string::npos) {
                    // Parse serving_size_amount
                    getline(file, line);
                    start = line.find(":") + 1;
                    string amountStr = line.substr(start);
                    commaPos = amountStr.find(",");
                    if (commaPos != string::npos) {
                        amountStr = amountStr.substr(0, commaPos);
                    }
                    amountStr = trim(amountStr);
                    // Remove quotes
                    if (!amountStr.empty() && amountStr.front() == '"')
                        amountStr = amountStr.substr(1);
                    if (!amountStr.empty() && amountStr.back() == '"')
                        amountStr.pop_back();
                    item.servingAmount = amountStr;

                    // Parse serving_size_unit
                    getline(file, line);
                    start = line.find(":") + 1;
                    string unitStr = line.substr(start);
                    commaPos = unitStr.find(",");
                    if (commaPos != string::npos) {
                        unitStr = unitStr.substr(0, commaPos);
                    }
                    unitStr = trim(unitStr);
                    // Remove quotes and any trailing characters
                    if (!unitStr.empty() && unitStr.front() == '\"')
                        unitStr = unitStr.substr(1);
                    if (!unitStr.empty() && unitStr.back() == '\"')
                        unitStr.pop_back();
                    // Remove any remaining special characters
                    size_t bracePos = unitStr.find('}');
                    if (bracePos != string::npos) {
                        unitStr = unitStr.substr(0, bracePos);
                    }
                    unitStr = trim(unitStr);
                    item.servingUnit = unitStr;

                    // NOTE david: Nutrislice nutrition values are already per serving,
                    // so we do NOT rescale them by servingAmount here.
                } else {
                    item.servingAmount = "1";
                    item.servingUnit = "serving";
                }

                menu.push_back(item);
            } catch (const exception& e) {
#ifdef DEBUG
                cerr << "Error parsing item '" << item.name
                     << "': " << e.what() << endl;
#endif
                continue;
            }
        }
    }

    file.close();

    // Sort items by station, then alphabetically by name within each station
    sort(menu.begin(), menu.end(), [](const FoodItem& a, const FoodItem& b) {
        if (a.station != b.station) {
            return a.station < b.station;
        }
        return a.name < b.name;
    });

    return menu;
}

// Get the menu for a specific meal and date
vector<FoodItem> MenuManager::getDailyMenu(const string& mealType,
                                           const string& date) {
    // Load from data/menus/{mealType}-{date}.json.
    // The JSON files are generated by menu.py.
    string filepath = "../data/menus/" + mealType + "-" + date + ".json";
    return loadMenuFromFile(filepath);
}

// Display menu as a simple numbered list
void MenuManager::displayMenu(const vector<FoodItem>& menu) {
    cout << "\n";
    for (size_t i = 0; i < menu.size(); i++) {
        cout << "  " << (i + 1) << ". " << menu[i].name << "\n";
    }
}

// Display menu as a formatted table with nutrition info
void MenuManager::displayMenuTable(const vector<FoodItem>& menu) {
    // ANSI color codes
    const string CYAN = "\033[36m";
    const string YELLOW = "\033[33m";
    const string GREEN = "\033[32m";
    const string RESET = "\033[0m";
    const string BOLD = "\033[1m";

    // Group items by station
    string currentStation = "";
    int itemNum = 1;

    for (const auto& item : menu) {
        // Print station header when it changes
        if (item.station != currentStation) {
            if (!currentStation.empty()) {
                cout << "\n";  // Space between stations
            }
            currentStation = item.station;
            cout << "  " << CYAN << BOLD << currentStation << RESET << "\n";
            cout << "  " << string(95, '-') << "\n";
            // Print table header
            cout << "  " << setw(5) << left << "#"
                 << "| " << setw(22) << "Name"
                 << "| " << setw(12) << "Cals/Serving"
                 << "| " << setw(12) << "Protein(g)"
                 << "| " << setw(11) << "Carbs(g)"
                 << "| " << setw(10) << "Fats(g)" << "\n";
            cout << "  " << string(95, '-') << "\n";
        }

        // Format calories with serving unit
        string calDisplay = to_string(item.calories) + "/" + item.servingUnit;

        // Format macros without units (just numbers)
        stringstream proteinDisplay, carbsDisplay, fatsDisplay;
        proteinDisplay << fixed << setprecision(1) << item.protein;
        carbsDisplay   << fixed << setprecision(1) << item.carbs;
        fatsDisplay    << fixed << setprecision(1) << item.fats;

        // Print item in table format
        cout << "  " << YELLOW << "[" << setw(3) << itemNum << "]" << RESET
             << "| " << setw(22) << left << item.name.substr(0, 21)
             << "| " << GREEN << setw(12) << calDisplay.substr(0, 11) << RESET
             << "| " << setw(12) << proteinDisplay.str()
             << "| " << setw(11) << carbsDisplay.str()
             << "| " << setw(10) << fatsDisplay.str() << "\n";

        itemNum++;
    }
}

// Generate a meal plan optimized for user's goals, using today's date
MenuManager::MealPlanResult MenuManager::generateMealPlan(const User& user) {
    MealPlanResult result{};

    // 1. Today's date as "YYYY-MM-DD"
    time_t now = time(nullptr);
    tm* ltm = localtime(&now);
    char dateBuf[11];
    strftime(dateBuf, sizeof(dateBuf), "%Y-%m-%d", ltm);
    result.dateStr = dateBuf;

    // 2. Daily macro goals in grams
    result.calorieGoal = user.calorieGoal;
    result.proteinGoal = (user.calorieGoal * user.macroRatio.protein) / 4.0;
    result.carbsGoal   = (user.calorieGoal * user.macroRatio.carbs)   / 4.0;
    result.fatsGoal    = (user.calorieGoal * user.macroRatio.fats)    / 9.0;

    // 3. Already-logged totals for today
    result.loggedTotals = calculateDailyTotals(user, result.dateStr);

    double remainingCalories = result.calorieGoal - result.loggedTotals.calories;
    double remainingProtein  = result.proteinGoal - result.loggedTotals.protein;
    double remainingCarbs    = result.carbsGoal   - result.loggedTotals.carbs;
    double remainingFats     = result.fatsGoal    - result.loggedTotals.fats;

    // 4. Which meals already have any logged items?
    bool bLogged = false, lLogged = false, dLogged = false;
    auto dateIt = user.loggedMeals.find(result.dateStr);
    if (dateIt != user.loggedMeals.end()) {
        const auto& dayLog = dateIt->second;
        auto itB = dayLog.find("breakfast");
        if (itB != dayLog.end() && !itB->second.empty()) bLogged = true;
        auto itL = dayLog.find("lunch");
        if (itL != dayLog.end() && !itL->second.empty()) lLogged = true;
        auto itD = dayLog.find("dinner");
        if (itD != dayLog.end() && !itD->second.empty()) dLogged = true;
    }

    result.mealLogged["breakfast"] = bLogged;
    result.mealLogged["lunch"]     = lLogged;
    result.mealLogged["dinner"]    = dLogged;

    // 5. Per-meal budgets for remaining meals (30/40/30 split across unlogged meals)
    struct MealTargets {
        double calories;
        double protein;
        double carbs;
        double fats;
    };

    std::map<std::string, MealTargets> mealBudgets;

    double bWeight = 0.3, lWeight = 0.4, dWeight = 0.3;
    double totalWeight = 0.0;

    if (!bLogged) totalWeight += bWeight;
    if (!lLogged) totalWeight += lWeight;
    if (!dLogged) totalWeight += dWeight;

    if (totalWeight <= 0.0) {
        // All meals already logged or no remaining budget â€“ nothing to plan.
        return result;
    }

    auto clamp = [](double x) { return x < 0.0 ? 0.0 : x; };

    if (!bLogged) {
        double ratio = bWeight / totalWeight;
        mealBudgets["breakfast"] = {
            clamp(remainingCalories * ratio),
            clamp(remainingProtein  * ratio),
            clamp(remainingCarbs    * ratio),
            clamp(remainingFats     * ratio)
        };
    }
    if (!lLogged) {
        double ratio = lWeight / totalWeight;
        mealBudgets["lunch"] = {
            clamp(remainingCalories * ratio),
            clamp(remainingProtein  * ratio),
            clamp(remainingCarbs    * ratio),
            clamp(remainingFats     * ratio)
        };
    }
    if (!dLogged) {
        double ratio = dWeight / totalWeight;
        mealBudgets["dinner"] = {
            clamp(remainingCalories * ratio),
            clamp(remainingProtein  * ratio),
            clamp(remainingCarbs    * ratio),
            clamp(remainingFats     * ratio)
        };
    }

    // 6. For each meal budget, use menu.py simplification + solver.py
    for (const auto& budgetPair : mealBudgets) {
        const std::string& mealType = budgetPair.first;
        const MealTargets& targets  = budgetPair.second;

        // Ensure the full Nutrislice menu JSON exists (normal, unsimplified)
        UIUtils::fetchMenuFor(result.dateStr, mealType);

        // Filenames under ../data/menus relative to the main/ directory
        std::string baseFilename       = mealType + "-" + result.dateStr + ".json";
        std::string simplifiedFilename = "simplified-" + baseFilename;
        std::string simplifiedPath     = "../data/menus/" + simplifiedFilename;
        std::string planPath           = "../data/menus/plan-" + mealType + "-" + result.dateStr + ".txt";

        // 6a. Use project-local virtualenv Python to create the simplified JSON.
#ifndef _WIN32
        const std::string PY = "../.venv/bin/python";

        std::string simplifyCmd =
            PY + " -c \"from menu import simplify_menu_file; "
            "simplify_menu_file('" + baseFilename + "')\""
            " > /dev/null 2>&1";
#else
        std::string simplifyCmd =
            "python -c \"from menu import simplify_menu_file; "
            "simplify_menu_file('" + baseFilename + "')\""
            " > NUL 2>&1";
#endif

        int simplifyStatus = std::system(simplifyCmd.c_str());
        if (simplifyStatus != 0) {
            std::cerr << "Error: simplify_menu_file failed for "
                    << baseFilename
                    << " with status " << simplifyStatus << std::endl;
            continue;  // skip this mealType
        }

        // 6b. Call solver.py on the simplified JSON with this meal's macro targets
        std::ostringstream targetStream;
        targetStream << targets.calories << " "
                    << targets.protein  << " "
                    << targets.carbs    << " "
                    << targets.fats;

#ifndef _WIN32
        std::string solverCmd =
            PY + " solver.py \"" + simplifiedPath + "\" " + targetStream.str() +
            " > \"" + planPath + "\" 2>/dev/null";
#else
        std::string solverCmd =
            "python solver.py \"" + simplifiedPath + "\" " + targetStream.str() +
            " > \"" + planPath + "\" 2>NUL";
#endif

        int solverStatus = std::system(solverCmd.c_str());
        if (solverStatus != 0) {
            std::cerr << "Error: solver.py failed for "
                    << simplifiedPath
                    << " with status " << solverStatus << std::endl;
            continue;  // skip this mealType
        }

        // 6c. Parse the solver output: each line "name<TAB>servings"
        std::ifstream planFile(planPath);
        if (!planFile.is_open()) {
            continue;
        }

        // Load the full (unsimplified) menu to get proper FoodItem metadata
        std::vector<FoodItem> fullMenu = getDailyMenu(mealType, result.dateStr);
        if (fullMenu.empty()) {
            continue;
        }

        std::string line;
        while (std::getline(planFile, line)) {
            if (line.empty()) continue;
            size_t tabPos = line.find('\t');
            if (tabPos == std::string::npos) continue;

            std::string itemName    = line.substr(0, tabPos);
            std::string servingsStr = line.substr(tabPos + 1);

            try {
                double servings = std::stod(servingsStr);

                auto it = std::find_if(
                    fullMenu.begin(), fullMenu.end(),
                    [&](const FoodItem& fi) { return fi.name == itemName; }
                );
                if (it != fullMenu.end() && servings > 0.0) {
                    MealPlanResult::PlannedItem planned;
                    planned.item     = *it;
                    planned.servings = servings;
                    result.selectedMeals[mealType].push_back(planned);
                }
            } catch (...) {
                // Ignore malformed lines
                continue;
            }
        }
    }

    return result;
}


// Log a meal item for a user
bool MenuManager::logMeal(User& user, const string& mealType,
                          const string& date, int menuNumber,
                          double servings) {
    // Get the menu for the specified meal and date
    vector<FoodItem> menu = getDailyMenu(mealType, date);

    // Check if menu number is valid
    if (menuNumber < 1 || menuNumber > static_cast<int>(menu.size())) {
        return false;
    }

    // Get the food item
    FoodItem item = menu[menuNumber - 1];

    // Add or update the logged meal using new structure: date -> mealType -> food
    user.loggedMeals[date][mealType][item.name] = servings;

    return true;
}

// Log a specific food item by name
bool MenuManager::logFoodItem(User& user, const string& mealType,
                              const string& date, const string& foodName,
                              double servings) {
    // Add to existing servings if it exists, otherwise create new entry
    user.loggedMeals[date][mealType][foodName] += servings;
    return true;
}

// Remove a logged meal for a user
bool MenuManager::removeLoggedMeal(User& user, const string& date, 
                                   const string& mealType, const string& foodName) {
    // Check if date exists
    auto dateIt = user.loggedMeals.find(date);
    if (dateIt == user.loggedMeals.end()) return false;

    // Check if meal type exists
    auto mealIt = dateIt->second.find(mealType);
    if (mealIt == dateIt->second.end()) return false;

    // Check if food exists
    auto foodIt = mealIt->second.find(foodName);
    if (foodIt == mealIt->second.end()) return false;

    // Remove it
    mealIt->second.erase(foodIt);
    return true;
}

// Calculate total nutrition for a specific date
MenuManager::DailyTotals MenuManager::calculateDailyTotals(
    const User& user, const string& date) {
    DailyTotals totals = {0, 0.0, 0.0, 0.0};

    // Check if this date exists in logged meals
    auto dateIt = user.loggedMeals.find(date);
    if (dateIt == user.loggedMeals.end()) {
        return totals;
    }

    // Iterate through all meals for this date (breakfast, lunch, dinner)
    for (const auto& mealEntry : dateIt->second) {
        string mealType = mealEntry.first;

        // Load the menu for this meal type to get nutrition info
        vector<FoodItem> menu = getDailyMenu(mealType, date);

        // Iterate through all logged food items
        for (const auto& foodEntry : mealEntry.second) {
            string foodName = foodEntry.first;
            double servings = foodEntry.second;

            // Find this food item in the menu
            for (const auto& item : menu) {
                if (item.name == foodName) {
                    totals.calories += static_cast<int>(item.calories * servings);
                    totals.protein  += item.protein * servings;
                    totals.carbs    += item.carbs * servings;
                    totals.fats     += item.fats * servings;
                    break;
                }
            }
        }
    }

    return totals;
}
