#include "MenuManager.h"
#include "UIUtils.h"
#include <fstream>
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <ctime>
#include <sstream>
#include <map>
#include <cmath>

using namespace std;

// Helper function to trim whitespace from string
static string trim(const string& str) {
    size_t first = str.find_first_not_of(" \t\n\r");
    if (first == string::npos) return "";
    size_t last = str.find_last_not_of(" \t\n\r");
    return str.substr(first, last - first + 1);
}

// Constructor - menus are loaded on-demand from JSON files
// generated by menu.py (see menu.py for details). The filepath parameter
// is kept only for backward compatibility and is unused.
MenuManager::MenuManager(const string& filepath) {
    (void)filepath;
}

// Load menu from specific file path (for date-specific menus)
vector<FoodItem> MenuManager::loadMenuFromFile(const string& filename) {
    vector<FoodItem> menu;
    ifstream file(filename);

    if (!file.is_open()) {
        return menu;  // Return empty menu if file doesn't exist
    }

    string line;
    string currentStation = "";

    // Skip opening brace
    getline(file, line);

    while (getline(file, line)) {
        // Check for station name (e.g., "Provisions 804": [)
        // But exclude "icons": [ which is not a station
        if (line.find("\":") != string::npos && line.find("[") != string::npos) {
            size_t start = line.find("\"") + 1;
            size_t end = line.find("\"", start);
            string possibleStation = line.substr(start, end - start);

            // Only update station if it's not "icons", "serving_size", etc.
            if (possibleStation != "icons" && possibleStation != "serving_size") {
                currentStation = possibleStation;
            }
            continue;
        }

        // Look for "name" field to identify a food item
        if (line.find("\"name\"") != string::npos) {
            FoodItem item;
            item.station = currentStation;

            try {
                // Parse name
                size_t start = line.find(":") + 1;
                size_t end = line.find_last_of("\"");
                start = line.find("\"", start) + 1;
                item.name = line.substr(start, end - start);

                // Skip ingredients line
                getline(file, line);

                // Skip "nutrition": { line
                getline(file, line);

                // Parse calories
                getline(file, line);
                start = line.find(":") + 1;
                string calStr = line.substr(start);
                size_t commaPos = calStr.find(",");
                if (commaPos != string::npos) {
                    calStr = calStr.substr(0, commaPos);
                }
                calStr = trim(calStr);
                item.calories = static_cast<int>(stod(calStr));

                // Parse g_fat
                getline(file, line);
                start = line.find(":") + 1;
                string fatStr = line.substr(start);
                commaPos = fatStr.find(",");
                if (commaPos != string::npos) {
                    fatStr = fatStr.substr(0, commaPos);
                }
                fatStr = trim(fatStr);
                item.fats = stod(fatStr);

                // Parse g_carbs
                getline(file, line);
                start = line.find(":") + 1;
                string carbStr = line.substr(start);
                commaPos = carbStr.find(",");
                if (commaPos != string::npos) {
                    carbStr = carbStr.substr(0, commaPos);
                }
                carbStr = trim(carbStr);
                item.carbs = stod(carbStr);

                // Parse g_protein
                getline(file, line);
                start = line.find(":") + 1;
                string proteinStr = line.substr(start);
                commaPos = proteinStr.find(",");
                if (commaPos != string::npos) {
                    proteinStr = proteinStr.substr(0, commaPos);
                }
                proteinStr = trim(proteinStr);
                item.protein = stod(proteinStr);

                // Skip closing brace of nutrition
                getline(file, line);

                // Parse serving_size
                getline(file, line);
                if (line.find("serving_size") != string::npos) {
                    // Parse serving_size_amount
                    getline(file, line);
                    start = line.find(":") + 1;
                    string amountStr = line.substr(start);
                    commaPos = amountStr.find(",");
                    if (commaPos != string::npos) {
                        amountStr = amountStr.substr(0, commaPos);
                    }
                    amountStr = trim(amountStr);
                    // Remove quotes
                    if (!amountStr.empty() && amountStr.front() == '"')
                        amountStr = amountStr.substr(1);
                    if (!amountStr.empty() && amountStr.back() == '"')
                        amountStr.pop_back();
                    item.servingAmount = amountStr;

                    // Parse serving_size_unit
                    getline(file, line);
                    start = line.find(":") + 1;
                    string unitStr = line.substr(start);
                    commaPos = unitStr.find(",");
                    if (commaPos != string::npos) {
                        unitStr = unitStr.substr(0, commaPos);
                    }
                    unitStr = trim(unitStr);
                    // Remove quotes and any trailing characters
                    if (!unitStr.empty() && unitStr.front() == '\"')
                        unitStr = unitStr.substr(1);
                    if (!unitStr.empty() && unitStr.back() == '\"')
                        unitStr.pop_back();
                    // Remove any remaining special characters
                    size_t bracePos = unitStr.find('}');
                    if (bracePos != string::npos) {
                        unitStr = unitStr.substr(0, bracePos);
                    }
                    unitStr = trim(unitStr);
                    item.servingUnit = unitStr;

                    // Convert nutrition to per-serving values
                    try {
                        double servingCount = stod(item.servingAmount);
                        if (servingCount > 0) {
                            item.calories = static_cast<int>(item.calories / servingCount);
                            item.protein = item.protein / servingCount;
                            item.carbs = item.carbs / servingCount;
                            item.fats = item.fats / servingCount;
                        }
                    } catch (...) {
                        // If parsing fails, keep original values
                    }
                } else {
                    item.servingAmount = "1";
                    item.servingUnit = "serving";
                }

                menu.push_back(item);
            } catch (const exception& e) {
#ifdef DEBUG
                cerr << "Error parsing item '" << item.name
                     << "': " << e.what() << endl;
#endif
                continue;
            }
        }
    }

    file.close();

    // Sort items by station, then alphabetically by name within each station
    sort(menu.begin(), menu.end(), [](const FoodItem& a, const FoodItem& b) {
        if (a.station != b.station) {
            return a.station < b.station;
        }
        return a.name < b.name;
    });

    return menu;
}

// Get the menu for a specific meal and date
vector<FoodItem> MenuManager::getDailyMenu(const string& mealType,
                                           const string& date) {
    // Load from data/menus/{mealType}-{date}.json.
    // The JSON files are generated by menu.py.
    string filepath = "../data/menus/" + mealType + "-" + date + ".json";
    return loadMenuFromFile(filepath);
}

// Display menu as a simple numbered list
void MenuManager::displayMenu(const vector<FoodItem>& menu) {
    cout << "\n";
    for (size_t i = 0; i < menu.size(); i++) {
        cout << "  " << (i + 1) << ". " << menu[i].name << "\n";
    }
}

// Display menu as a formatted table with nutrition info
void MenuManager::displayMenuTable(const vector<FoodItem>& menu) {
    // ANSI color codes
    const string CYAN = "\033[36m";
    const string YELLOW = "\033[33m";
    const string GREEN = "\033[32m";
    const string RESET = "\033[0m";
    const string BOLD = "\033[1m";

    // Group items by station
    string currentStation = "";
    int itemNum = 1;

    for (const auto& item : menu) {
        // Print station header when it changes
        if (item.station != currentStation) {
            if (!currentStation.empty()) {
                cout << "\n";  // Space between stations
            }
            currentStation = item.station;
            cout << "  " << CYAN << BOLD << currentStation << RESET << "\n";
            cout << "  " << string(95, '-') << "\n";
            // Print table header
            cout << "  " << setw(5) << left << "#"
                 << "| " << setw(22) << "Name"
                 << "| " << setw(12) << "Cals/Serving"
                 << "| " << setw(12) << "Protein(g)"
                 << "| " << setw(11) << "Carbs(g)"
                 << "| " << setw(10) << "Fats(g)" << "\n";
            cout << "  " << string(95, '-') << "\n";
        }

        // Format calories with serving unit
        string calDisplay = to_string(item.calories) + "/" + item.servingUnit;

        // Format macros without units (just numbers)
        stringstream proteinDisplay, carbsDisplay, fatsDisplay;
        proteinDisplay << fixed << setprecision(1) << item.protein;
        carbsDisplay   << fixed << setprecision(1) << item.carbs;
        fatsDisplay    << fixed << setprecision(1) << item.fats;

        // Print item in table format
        cout << "  " << YELLOW << "[" << setw(3) << itemNum << "]" << RESET
             << "| " << setw(22) << left << item.name.substr(0, 21)
             << "| " << GREEN << setw(12) << calDisplay.substr(0, 11) << RESET
             << "| " << setw(12) << proteinDisplay.str()
             << "| " << setw(11) << carbsDisplay.str()
             << "| " << setw(10) << fatsDisplay.str() << "\n";

        itemNum++;
    }
}

// Generate a meal plan optimized for user's goals
// Generate a meal plan optimized for user's goals, using today's date
MenuManager::MealPlanResult MenuManager::generateMealPlan(const User& user) {
    MealPlanResult result{};

    // 1. Figure out today's date as "YYYY-MM-DD"
    time_t now = time(nullptr);
    tm* ltm = localtime(&now);
    char dateBuf[11];
    strftime(dateBuf, sizeof(dateBuf), "%Y-%m-%d", ltm);
    result.dateStr = dateBuf;

    // 2. Daily macro goals in grams
    result.calorieGoal = user.calorieGoal;
    result.proteinGoal = (user.calorieGoal * user.macroRatio.protein) / 4.0;
    result.carbsGoal   = (user.calorieGoal * user.macroRatio.carbs)   / 4.0;
    result.fatsGoal    = (user.calorieGoal * user.macroRatio.fats)    / 9.0;

    // 3. What has already been logged for today?
    result.loggedTotals = calculateDailyTotals(user, result.dateStr);

    double remainingCalories = user.calorieGoal - result.loggedTotals.calories;
    double remainingProtein  = result.proteinGoal - result.loggedTotals.protein;
    double remainingCarbs    = result.carbsGoal   - result.loggedTotals.carbs;
    double remainingFats     = result.fatsGoal    - result.loggedTotals.fats;

    // 4. Which meals already have any logged items?
    bool bLogged = false, lLogged = false, dLogged = false;
    auto dateIt = user.loggedMeals.find(result.dateStr);
    if (dateIt != user.loggedMeals.end()) {
        const auto& dayLog = dateIt->second;
        auto itB = dayLog.find("breakfast");
        if (itB != dayLog.end() && !itB->second.empty()) bLogged = true;
        auto itL = dayLog.find("lunch");
        if (itL != dayLog.end() && !itL->second.empty()) lLogged = true;
        auto itD = dayLog.find("dinner");
        if (itD != dayLog.end() && !itD->second.empty()) dLogged = true;
    }

    result.mealLogged["breakfast"] = bLogged;
    result.mealLogged["lunch"]     = lLogged;
    result.mealLogged["dinner"]    = dLogged;

    // 5. Define meal budgets for remaining meals (30/40/30 split)
    struct MealTargets {
        double calories;
        double protein;
        double carbs;
        double fats;
    };

    std::map<std::string, MealTargets> mealBudgets;

    double bWeight = 0.3, lWeight = 0.4, dWeight = 0.3;
    double totalWeight = 0.0;

    if (!bLogged) totalWeight += bWeight;
    if (!lLogged) totalWeight += lWeight;
    if (!dLogged) totalWeight += dWeight;

    if (totalWeight > 0.0) {
        if (!bLogged) {
            double ratio = bWeight / totalWeight;
            mealBudgets["breakfast"] = {
                remainingCalories * ratio,
                remainingProtein  * ratio,
                remainingCarbs    * ratio,
                remainingFats     * ratio
            };
        }
        if (!lLogged) {
            double ratio = lWeight / totalWeight;
            mealBudgets["lunch"] = {
                remainingCalories * ratio,
                remainingProtein  * ratio,
                remainingCarbs    * ratio,
                remainingFats     * ratio
            };
        }
        if (!dLogged) {
            double ratio = dWeight / totalWeight;
            mealBudgets["dinner"] = {
                remainingCalories * ratio,
                remainingProtein  * ratio,
                remainingCarbs    * ratio,
                remainingFats     * ratio
            };
        }
    } else {
        // All meals already logged or no remaining budget â€“ nothing to plan.
        return result;
    }

    // 6. Ensure menus for today exist (calls Python script via UIUtils)
    UIUtils::fetchMenuFor(result.dateStr, "breakfast");
    UIUtils::fetchMenuFor(result.dateStr, "lunch");
    UIUtils::fetchMenuFor(result.dateStr, "dinner");

    std::map<std::string, std::vector<FoodItem>> allMenus;
    allMenus["breakfast"] = getDailyMenu("breakfast", result.dateStr);
    allMenus["lunch"]     = getDailyMenu("lunch",     result.dateStr);
    allMenus["dinner"]    = getDailyMenu("dinner",    result.dateStr);

    if (allMenus["breakfast"].empty() &&
        allMenus["lunch"].empty() &&
        allMenus["dinner"].empty()) {
        // No menus available at all.
        return result;
    }

    // 7. Algorithm: pick the best-fitting item for each meal's budget
    for (const auto& budgetPair : mealBudgets) {
        const std::string& mealType = budgetPair.first;
        const MealTargets& targets  = budgetPair.second;
        const std::vector<FoodItem>& currentMenu = allMenus[mealType];

        if (currentMenu.empty()) continue;

        FoodItem bestItemForMeal;
        double bestScore = -1.0;

        for (const auto& item : currentMenu) {
            // Score based on how well the item fits this meal's budget.
            double calorieScore = 1.0 - (std::fabs(item.calories - targets.calories) /
                                         std::max(targets.calories, 1.0));
            double proteinScore = 1.0 - (std::fabs(item.protein - targets.protein) /
                                         std::max(targets.protein, 1.0));
            double carbsScore   = 1.0 - (std::fabs(item.carbs   - targets.carbs) /
                                         std::max(targets.carbs,   1.0));
            double fatsScore    = 1.0 - (std::fabs(item.fats    - targets.fats) /
                                         std::max(targets.fats,    1.0));

            // Weighted average; calories most important (matches old UI logic).
            double finalScore =
                0.5  * calorieScore +
                0.2  * proteinScore +
                0.15 * carbsScore   +
                0.15 * fatsScore;

            if (finalScore > bestScore) {
                bestScore = finalScore;
                bestItemForMeal = item;
            }
        }

        // Store best item for this meal type
        result.selectedMeals[mealType] = bestItemForMeal;
    }

    return result;
}

// Log a meal item for a user
bool MenuManager::logMeal(User& user, const string& mealType,
                          const string& date, int menuNumber,
                          double servings) {
    // Get the menu for the specified meal and date
    vector<FoodItem> menu = getDailyMenu(mealType, date);

    // Check if menu number is valid
    if (menuNumber < 1 || menuNumber > static_cast<int>(menu.size())) {
        return false;
    }

    // Get the food item
    FoodItem item = menu[menuNumber - 1];

    // Add or update the logged meal using new structure: date -> mealType -> food
    user.loggedMeals[date][mealType][item.name] = servings;

    return true;
}

// Log a specific food item by name
bool MenuManager::logFoodItem(User& user, const string& mealType,
                              const string& date, const string& foodName,
                              double servings) {
    // Add to existing servings if it exists, otherwise create new entry
    user.loggedMeals[date][mealType][foodName] += servings;
    return true;
}

// Remove a logged meal for a user
bool MenuManager::removeLoggedMeal(User& user, const string& date, 
                                   const string& mealType, const string& foodName) {
    // Check if date exists
    auto dateIt = user.loggedMeals.find(date);
    if (dateIt == user.loggedMeals.end()) return false;

    // Check if meal type exists
    auto mealIt = dateIt->second.find(mealType);
    if (mealIt == dateIt->second.end()) return false;

    // Check if food exists
    auto foodIt = mealIt->second.find(foodName);
    if (foodIt == mealIt->second.end()) return false;

    // Remove it
    mealIt->second.erase(foodIt);
    return true;
}

// Calculate total nutrition for a specific date
MenuManager::DailyTotals MenuManager::calculateDailyTotals(
    const User& user, const string& date) {
    DailyTotals totals = {0, 0.0, 0.0, 0.0};

    // Check if this date exists in logged meals
    auto dateIt = user.loggedMeals.find(date);
    if (dateIt == user.loggedMeals.end()) {
        return totals;
    }

    // Iterate through all meals for this date (breakfast, lunch, dinner)
    for (const auto& mealEntry : dateIt->second) {
        string mealType = mealEntry.first;

        // Load the menu for this meal type to get nutrition info
        vector<FoodItem> menu = getDailyMenu(mealType, date);

        // Iterate through all logged food items
        for (const auto& foodEntry : mealEntry.second) {
            string foodName = foodEntry.first;
            double servings = foodEntry.second;

            // Find this food item in the menu
            for (const auto& item : menu) {
                if (item.name == foodName) {
                    totals.calories += static_cast<int>(item.calories * servings);
                    totals.protein  += item.protein * servings;
                    totals.carbs    += item.carbs * servings;
                    totals.fats     += item.fats * servings;
                    break;
                }
            }
        }
    }

    return totals;
}
